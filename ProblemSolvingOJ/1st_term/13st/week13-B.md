
### 1. 考察知识：关系、格、找环

一句话题解：其实就是第11周的数环上结点数，减去一元和二元环，判断是否为0

本期的标题和数据描述中都埋下了伏笔，使得在得到解法后让人感到意料之外，情理之中

不要怕文字多，看完（一）（二）其实就能做出题目了

题面可以直观理解为定义了一个没有反对称性的格（若上（下）确界的元素有多个但等价则也算作唯一）
或者以一个例子理解
：x，y，z是三个符号，可以有f(x)=a, f(y)=a, f(z)=a
但此时若关系(x,y)存在于R', 即(a,a)存在于R''，则要求(y,x), (x,z), (y,z), (z,x), (z,y)也都存在于R'
由于问的是 存在S存在f，故S和f可以随便你构造，只要满足那些条件即可




R'要求反身性和传递性

（一）我们首先考虑自反性，对于(x,x)在R中初始存在的，不用管，不存在的加上即可，故该特性在任意


（二）传递性，若(a,b)且(b,c)我们可以加上(a,c)，但如果(c,a)存在则不能加，故若存在(a,b), (b,c), (c,a)则无法满足传递性
即存在三元环（有三个结点/边构成的环，边数和点数是相等的）则无法满足
那么二元环可以吗，可以的，因为虽然有了(a,b)不能新加入(b,a) R中如果有(a,b)(b,a)则我们可以将a，b映射为R''中的同一个元素

那么四元及以上的环可以吗，对于某个n(n>=3)元环，即(a,b), (b,c), ... , (z, a) 属于R， （a,b,c是互不相同的L中的元素，且z不同于a,b；但z和c可以是同一个）

选取其中相邻的两个元素a,b,
则(b,a)不属于R （因为每个L中的元素只指向恰好一个元素，而b指向了c）
又由传递性可知(b,a)应当属于R'
但又有  若(a,b)属于R则(b,a)不属于 R'-R的要求
故此时无合法方案

知道这些，你其实已经可以解决这个问题了，当然，以下是对正确性的説明，
你可以直接自己手动画一画，找找规律


（三）等价元素关系一致（若f(a)=f(b) 则 （(若(x,a)属于R'则(x,b)属于R') 且(若(a,x)属于R'则(b,x)属于R') ））

我们已经排除了n(n>=3)元环
我们令每个二元环上的两个元素映射为同一个S中的元素（不同二元环映射到不同的元素），其余都映射为独立的元素即可，

（四）格上下确界唯一
由于初始情况下每个L中的元素只指向一个别的L中的元素，故补全自反和传递后，并将二元环映射为S中的一个元素之后
不可能出现最紧上（下）界有2个及以上的情况 // 可以自己画图直观理解一下，读者可以自行证明 : )

（五）任意两个元素存在上下确界

由于初始情况下每个元素只有一个指向其他元素的边
所以其实这个结构会形成一个基环树森林
基环树：可以有至多一个环，在删去环上任意一条边后变成树
森林：若干不相交的树（这里是基环树），构成的图

在映射二元环之后，（不存在n(n>=3)元环）基环树森林变成了森林

我们令(a,b)属于R'表示b是a的祖先
若一个元素是该元素所在树中所有元素的祖先，则该元素称为根
令root(Tree_(i))表示Tree_(i)的根

我们将若干棵树以任意顺序排列，编号为Tree_(1), Tree_(2), ..., Tree_(m)
对任意i 属于 {1, 2, ..., m - 1}
添加关系(Tree_(i) , Tree_(i+1)) 到R'中 （由于不同的树之间没有边故可以添加）

然后任意选取Tree(1)中的一个叶子结点leaf
将leaf向所有其他结点连边（即使得任意x属于L，有(leaf, x)属于R'）
由于leaf是叶子结点，没有其他结点指向它，故连边可以进行

然后补全传递性
得到的即一个合法方案

所以解法是：若除了自环（自己和自己有关系）和2元环（(a,b), (b,a)） 之外没有其他的环
则存在方案，否则不存在

直接照搬11周的代码，然后减去一元和二元环即可


### 2. 优秀代码
**一**
作者：张浩宇
助教自己写的


```c++
#include <bits/stdc++.h>
using namespace std;
const int MXN = 2e5 + 10;
int number[MXN], d[MXN];
int n;
template <typename Type>
	void read(Type &a) {//读入优化，可以忽略
		int t;
		while (!isdigit(t = getchar()));
		a = t - '0';
		while ( isdigit(t = getchar())) {
			a *= 10;
			a += t - '0';
		}
	}
void calc() {
	memset(number + 1, 0, n * sizeof(int));
	int ans = 0;
	read(n);
	for (int i = 1; i <= n; ++i) read(d[i]);
    int idx = 0;
	for (int i = 1; i <= n; ++i) if (!number[i]) {
	    int begin = idx + 1;
		int nd = i;
		while (!number[nd]) {
			number[nd] = ++idx; 
			nd = d[nd];
		}
		if (number[nd] >= begin) {
			ans += idx - number[nd] + 1;
		}
	}
	for (int i = 1; i <= n; ++i) {//减去一元和二元环
		ans -= d[d[i]] == i;
	}
	printf("%c\n", ans ? 'N' : 'Y');
}
int main() {
	int T;
	read(T);
	while (T--) calc();
	return 0;
}


```
更多算法直接看11周的找环的题解即可
当然也可以不计数，只判断有没有三元及以上的环